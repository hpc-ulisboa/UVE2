
### Attempting to compile and run kernel 3mm (size: 2500, type: byte) ...


benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
                for (k = 0; k < sizeK; k++)
                ^
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 3765984 less instructions
RVV executed 33653 more instructions
UVE executed 3439535 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3452776  | 3486429 | 33653      | 0.97           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3812878  | 46894   | -3765984   | -98.77         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3486429  | 46894   | -3439535   | -98.65         |
|----------|---------|------------|----------------|


Kernel 3mm is similar enough

### Attempting to compile and run kernel 3mm (size: 2500, type: half-word) ...


benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
                for (k = 0; k < sizeK; k++)
                ^
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 3743543 less instructions
RVV executed 74463 more instructions
UVE executed 3465351 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3462143  | 3536606 | 74463      | 2.15           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3814798  | 71255   | -3743543   | -98.13         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3536606  | 71255   | -3465351   | -97.99         |
|----------|---------|------------|----------------|


Kernel 3mm is similar enough

### Attempting to compile and run kernel 3mm (size: 2500, type: integer) ...


benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
                for (k = 0; k < sizeK; k++)
                ^
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 2948543 less instructions
RVV executed 79829 more instructions
UVE executed 3425717 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3469587  | 3549416 | 79829      | 2.30           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3072242  | 123699  | -2948543   | -95.97         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3549416  | 123699  | -3425717   | -96.51         |
|----------|---------|------------|----------------|


Kernel 3mm is similar enough

### Attempting to compile and run kernel 3mm (size: 2500, type: float) ...


benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
                for (k = 0; k < sizeK; k++)
                ^
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 2573543 less instructions
RVV executed 67130 more instructions
UVE executed 3038021 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3094590  | 3161720 | 67130      | 2.17           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 2697242  | 123699  | -2573543   | -95.41         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3161720  | 123699  | -3038021   | -96.09         |
|----------|---------|------------|----------------|


Kernel 3mm is similar enough

### Attempting to compile and run kernel 3mm (size: 2500, type: double) ...


benchmarks/3mm/kernel.c:231:10: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
                for (k = 0; k < sizeK; k++)
                ^
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/3mm/kernel.c:231:10: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 2506043 less instructions
RVV executed 74424 more instructions
UVE executed 2977815 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3109478  | 3183902 | 74424      | 2.39           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 2712130  | 206087  | -2506043   | -92.40         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 3183902  | 206087  | -2977815   | -93.53         |
|----------|---------|------------|----------------|


Kernel 3mm is similar enough

### Attempting to compile and run kernel convolution (size: 2500, type: byte) ...


benchmarks/convolution/kernel.c:585:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (x = 1; x < PB_J - 1; x++){
        ^
benchmarks/convolution/kernel.c:585:9: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 94159 less instructions
RVV executed 139744 less instructions
UVE executed 96970 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 237618   | 97874 | -139744    | -58.81         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 95063    | 904   | -94159     | -99.05         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 97874    | 904   | -96970     | -99.08         |
|----------|-------|------------|----------------|


Kernel convolution is similar enough

### Attempting to compile and run kernel convolution (size: 2500, type: half-word) ...


benchmarks/convolution/kernel.c:585:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (x = 1; x < PB_J - 1; x++){
        ^
benchmarks/convolution/kernel.c:585:9: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 93293 less instructions
RVV executed 201419 less instructions
UVE executed 36736 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 239923   | 38504 | -201419    | -83.95         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 95061    | 1768  | -93293     | -98.14         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 38504    | 1768  | -36736     | -95.41         |
|----------|-------|------------|----------------|


Kernel convolution is similar enough

### Attempting to compile and run kernel convolution (size: 2500, type: integer) ...


benchmarks/convolution/kernel.c:585:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (x = 1; x < PB_J - 1; x++){
        ^
benchmarks/convolution/kernel.c:585:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 92283 less instructions
RVV executed 231322 less instructions
UVE executed 5969 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 239923   | 8601 | -231322    | -96.42         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 94915    | 2632 | -92283     | -97.23         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 8601     | 2632 | -5969      | -69.40         |
|----------|------|------------|----------------|


Kernel convolution is similar enough

### Attempting to compile and run kernel convolution (size: 2500, type: float) ...


benchmarks/convolution/kernel.c:585:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (x = 1; x < PB_J - 1; x++){
        ^
benchmarks/convolution/kernel.c:585:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 73851 less instructions
RVV executed 210976 less instructions
UVE executed 5580 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 219188   | 8212 | -210976    | -96.25         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 76483    | 2632 | -73851     | -96.56         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 8212     | 2632 | -5580      | -67.95         |
|----------|------|------------|----------------|


Kernel convolution is similar enough

### Attempting to compile and run kernel convolution (size: 2500, type: double) ...


benchmarks/convolution/kernel.c:585:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (x = 1; x < PB_J - 1; x++){
        ^
benchmarks/convolution/kernel.c:585:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 71259 less instructions
RVV executed 206368 less instructions
UVE executed 7596 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 219188   | 12820 | -206368    | -94.15         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 76483    | 5224  | -71259     | -93.17         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 12820    | 5224  | -7596      | -59.25         |
|----------|-------|------------|----------------|


Kernel convolution is similar enough

### Attempting to compile and run kernel covariance (size: 2500, type: byte) ...


benchmarks/covariance/kernel.c:488:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (i = 0; i < sizeN; i++)
        ^
benchmarks/covariance/kernel.c:488:9: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/covariance/kernel.c:502:9: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeM; j++)
        ^
benchmarks/covariance/kernel.c:521:32: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/covariance/kernel.c:517:13 [-Rpass-analysis=loop-vectorize]
            cov[j * sizeM + i] = cov[i * sizeM + j];
                               ^
benchmarks/covariance/kernel.c:516:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (j = i; j < sizeM; j++) {
        ^
benchmarks/covariance/kernel.c:518:13: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
            for (k = 0; k < sizeN; k++)
            ^

UVE executed 808679 less instructions
RVV executed 7357 more instructions
UVE executed 628420 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 632922   | 640279 | 7357       | 1.16           |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 820538   | 11859  | -808679    | -98.55         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 640279   | 11859  | -628420    | -98.15         |
|----------|--------|------------|----------------|


Kernel covariance is similar enough

### Attempting to compile and run kernel covariance (size: 2500, type: half-word) ...


benchmarks/covariance/kernel.c:488:9: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
        for (i = 0; i < sizeN; i++)
        ^
benchmarks/covariance/kernel.c:502:9: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeM; j++)
        ^
benchmarks/covariance/kernel.c:521:32: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/covariance/kernel.c:517:13 [-Rpass-analysis=loop-vectorize]
            cov[j * sizeM + i] = cov[i * sizeM + j];
                               ^
benchmarks/covariance/kernel.c:516:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (j = i; j < sizeM; j++) {
        ^
benchmarks/covariance/kernel.c:518:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
            for (k = 0; k < sizeN; k++)
            ^
benchmarks/covariance/kernel.c:518:13: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 803756 less instructions
RVV executed 292992 less instructions
UVE executed 326647 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 635523   | 342531 | -292992    | -46.10         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 819640   | 15884  | -803756    | -98.06         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 342531   | 15884  | -326647    | -95.36         |
|----------|--------|------------|----------------|


Kernel covariance is similar enough

### Attempting to compile and run kernel covariance (size: 2500, type: integer) ...


benchmarks/covariance/kernel.c:488:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (i = 0; i < sizeN; i++)
        ^
benchmarks/covariance/kernel.c:502:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeM; j++)
        ^
benchmarks/covariance/kernel.c:521:32: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/covariance/kernel.c:517:13 [-Rpass-analysis=loop-vectorize]
            cov[j * sizeM + i] = cov[i * sizeM + j];
                               ^
benchmarks/covariance/kernel.c:516:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (j = i; j < sizeM; j++) {
        ^
benchmarks/covariance/kernel.c:518:13: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
            for (k = 0; k < sizeN; k++)
            ^

UVE executed 663871 less instructions
RVV executed 296940 less instructions
UVE executed 311997 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 632871   | 335931 | -296940    | -46.92         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 687805   | 23934  | -663871    | -96.52         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 335931   | 23934  | -311997    | -92.88         |
|----------|--------|------------|----------------|


Kernel covariance is similar enough

### Attempting to compile and run kernel covariance (size: 2500, type: float) ...


benchmarks/covariance/kernel.c:488:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (i = 0; i < sizeN; i++)
        ^
benchmarks/covariance/kernel.c:502:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeM; j++)
        ^
benchmarks/covariance/kernel.c:521:32: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/covariance/kernel.c:517:13 [-Rpass-analysis=loop-vectorize]
            cov[j * sizeM + i] = cov[i * sizeM + j];
                               ^
benchmarks/covariance/kernel.c:516:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (j = i; j < sizeM; j++) {
        ^
benchmarks/covariance/kernel.c:518:13: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
            for (k = 0; k < sizeN; k++)
            ^

UVE executed 600118 less instructions
RVV executed 254916 less instructions
UVE executed 290278 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 569128   | 314212 | -254916    | -44.79         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 624052   | 23934  | -600118    | -96.16         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 314212   | 23934  | -290278    | -92.38         |
|----------|--------|------------|----------------|


Kernel covariance is similar enough

### Attempting to compile and run kernel covariance (size: 2500, type: double) ...


benchmarks/covariance/kernel.c:488:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (i = 0; i < sizeN; i++)
        ^
benchmarks/covariance/kernel.c:488:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/covariance/kernel.c:502:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (j = 0; j < sizeM; j++)
        ^
benchmarks/covariance/kernel.c:502:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/covariance/kernel.c:521:32: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/covariance/kernel.c:517:13 [-Rpass-analysis=loop-vectorize]
            cov[j * sizeM + i] = cov[i * sizeM + j];
                               ^
benchmarks/covariance/kernel.c:516:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (j = i; j < sizeM; j++) {
        ^
benchmarks/covariance/kernel.c:518:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
            for (k = 0; k < sizeN; k++)
            ^
benchmarks/covariance/kernel.c:518:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 588043 less instructions
RVV executed 403810 less instructions
UVE executed 129309 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 569128   | 165318 | -403810    | -70.95         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 624052   | 36009  | -588043    | -94.23         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 165318   | 36009  | -129309    | -78.22         |
|----------|--------|------------|----------------|


Kernel covariance is similar enough

### Attempting to compile and run kernel gemm (size: 2500, type: byte) ...


benchmarks/gemm/kernel.c:342:8: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
       for (j = 0; j < sizeJ; j++)
       ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j = 0; j < sizeJ; j++)
    ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 1265337 less instructions
RVV executed 7953 more instructions
UVE executed 1408135 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1410357  | 1418310 | 7953       | 0.56           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1275512  | 10175   | -1265337   | -99.20         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1418310  | 10175   | -1408135   | -99.28         |
|----------|---------|------------|----------------|


Kernel gemm is similar enough

### Attempting to compile and run kernel gemm (size: 2500, type: half-word) ...


benchmarks/gemm/kernel.c:342:8: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
       for (j = 0; j < sizeJ; j++)
       ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j = 0; j < sizeJ; j++)
    ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 1255244 less instructions
RVV executed 21007 more instructions
UVE executed 1413591 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1412859  | 1433866 | 21007      | 1.49           |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1275519  | 20275   | -1255244   | -98.41         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1433866  | 20275   | -1413591   | -98.59         |
|----------|---------|------------|----------------|


Kernel gemm is similar enough

### Attempting to compile and run kernel gemm (size: 2500, type: integer) ...


benchmarks/gemm/kernel.c:342:8: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
       for (j = 0; j < sizeJ; j++)
       ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j = 0; j < sizeJ; j++)
    ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 1235040 less instructions
RVV executed 712634 less instructions
UVE executed 659750 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 1412859  | 700225 | -712634    | -50.44         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 1275515  | 40475  | -1235040   | -96.83         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 700225   | 40475  | -659750    | -94.22         |
|----------|--------|------------|----------------|


Kernel gemm is similar enough

### Attempting to compile and run kernel gemm (size: 2500, type: float) ...


benchmarks/gemm/kernel.c:342:8: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
       for (j = 0; j < sizeJ; j++)
       ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j = 0; j < sizeJ; j++)
    ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]

UVE executed 1110038 less instructions
RVV executed 680287 less instructions
UVE executed 567147 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 1287909  | 607622 | -680287    | -52.82         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 1150513  | 40475  | -1110038   | -96.48         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 607622   | 40475  | -567147    | -93.34         |
|----------|--------|------------|----------------|


Kernel gemm is similar enough

### Attempting to compile and run kernel gemm (size: 2500, type: double) ...


benchmarks/gemm/kernel.c:342:8: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
       for (j = 0; j < sizeJ; j++)
       ^
benchmarks/gemm/kernel.c:342:8: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/gemm/kernel.c:339:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (j = 0; j < sizeJ; j++)
    ^
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/gemm/kernel.c:339:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/gemm/kernel.c:339:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 1079738 less instructions
RVV executed 1003988 less instructions
UVE executed 213146 less instructions than RVV
|----------|--------|------------|----------------|
| Original | RVV    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 1287909  | 283921 | -1003988   | -77.95         |
|----------|--------|------------|----------------|
| Original | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 1150513  | 70775  | -1079738   | -93.85         |
|----------|--------|------------|----------------|
| RVV      | UVE    | Difference | Difference (%) |
|----------|--------|------------|----------------|
| 283921   | 70775  | -213146    | -75.07         |
|----------|--------|------------|----------------|


Kernel gemm is similar enough

### Attempting to compile and run kernel gemver (size: 2500, type: byte) ...


benchmarks/gemver/kernel.c:637:9: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:641:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:641:9: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/gemver/kernel.c:644:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (i = 0; i < sizeN; i++)
    ^
benchmarks/gemver/kernel.c:648:9: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^

UVE executed 90186 less instructions
RVV executed 538 more instructions
UVE executed 88706 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 89163    | 89701 | 538        | 0.60           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 91181    | 995   | -90186     | -98.91         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 89701    | 995   | -88706     | -98.89         |
|----------|-------|------------|----------------|


Kernel gemver is similar enough

### Attempting to compile and run kernel gemver (size: 2500, type: half-word) ...


benchmarks/gemver/kernel.c:637:9: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:641:9: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:644:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (i = 0; i < sizeN; i++)
    ^
benchmarks/gemver/kernel.c:648:9: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^

UVE executed 89510 less instructions
RVV executed 995 more instructions
UVE executed 88662 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 89314    | 90309 | 995        | 1.11           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 91157    | 1647  | -89510     | -98.19         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 90309    | 1647  | -88662     | -98.18         |
|----------|-------|------------|----------------|


Kernel gemver is similar enough

### Attempting to compile and run kernel gemver (size: 2500, type: integer) ...


benchmarks/gemver/kernel.c:637:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:641:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:644:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (i = 0; i < sizeN; i++)
    ^
benchmarks/gemver/kernel.c:648:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^

UVE executed 78364 less instructions
RVV executed 47221 less instructions
UVE executed 39142 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 89314    | 42093 | -47221     | -52.87         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 81315    | 2951  | -78364     | -96.37         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 42093    | 2951  | -39142     | -92.99         |
|----------|-------|------------|----------------|


Kernel gemver is similar enough

### Attempting to compile and run kernel gemver (size: 2500, type: float) ...


benchmarks/gemver/kernel.c:637:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:641:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:644:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (i = 0; i < sizeN; i++)
    ^
benchmarks/gemver/kernel.c:648:9: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^

UVE executed 68362 less instructions
RVV executed 41224 less instructions
UVE executed 35139 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 79314    | 38090 | -41224     | -51.98         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 71313    | 2951  | -68362     | -95.86         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 38090    | 2951  | -35139     | -92.25         |
|----------|-------|------------|----------------|


Kernel gemver is similar enough

### Attempting to compile and run kernel gemver (size: 2500, type: double) ...


benchmarks/gemver/kernel.c:637:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:637:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/gemver/kernel.c:641:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:641:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/gemver/kernel.c:644:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (i = 0; i < sizeN; i++)
    ^
benchmarks/gemver/kernel.c:644:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/gemver/kernel.c:648:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (j = 0; j < sizeN; j++)
        ^
benchmarks/gemver/kernel.c:648:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 66406 less instructions
RVV executed 60525 less instructions
UVE executed 13882 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 79314    | 18789 | -60525     | -76.31         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 71313    | 4907  | -66406     | -93.12         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 18789    | 4907  | -13882     | -73.88         |
|----------|-------|------------|----------------|


Kernel gemver is similar enough

### Attempting to compile and run kernel jacobi-1d (size: 2500, type: float) ...


benchmarks/jacobi-1d/kernel.c:109:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (int i = 1; i < SIZE - 1; ++i)
    ^
benchmarks/jacobi-1d/kernel.c:112:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (int i = 1; i < SIZE - 1; ++i)
    ^

UVE executed 48697 less instructions
RVV executed 50952 less instructions
UVE executed 2740 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 54966    | 4014 | -50952     | -92.70         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 49971    | 1274 | -48697     | -97.45         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 4014     | 1274 | -2740      | -68.26         |
|----------|------|------------|----------------|


Kernel jacobi-1d is similar enough

### Attempting to compile and run kernel jacobi-1d (size: 2500, type: double) ...


benchmarks/jacobi-1d/kernel.c:109:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 1; i < SIZE - 1; ++i)
    ^
benchmarks/jacobi-1d/kernel.c:109:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/jacobi-1d/kernel.c:112:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 1; i < SIZE - 1; ++i)
    ^
benchmarks/jacobi-1d/kernel.c:112:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 47449 less instructions
RVV executed 46759 less instructions
UVE executed 5685 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 54966    | 8207 | -46759     | -85.07         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 49971    | 2522 | -47449     | -94.95         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 8207     | 2522 | -5685      | -69.27         |
|----------|------|------------|----------------|


Kernel jacobi-1d is similar enough

### Attempting to compile and run kernel jacobi-2d (size: 2500, type: float) ...


benchmarks/jacobi-2d/kernel.c:211:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int j = 1; j < SIZE - 1; j++) {
    ^
benchmarks/jacobi-2d/kernel.c:211:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/jacobi-2d/kernel.c:212:28: remark: floating point conversion changes vector width. Mixed floating point precision requires an up/down cast that will negatively impact performance. [-Rpass-analysis=loop-vectorize]
      B[i*SIZE+j] = 0.2  * (A[i*SIZE+j] + A[i*SIZE+j-1] + A[i*SIZE+j+1] + A[(i+1)*SIZE+j] + A[(i-1)*SIZE+j]);
                           ^
benchmarks/jacobi-2d/kernel.c:216:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int j = 1; j < SIZE - 1; j++) {
    ^
benchmarks/jacobi-2d/kernel.c:216:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/jacobi-2d/kernel.c:217:28: remark: floating point conversion changes vector width. Mixed floating point precision requires an up/down cast that will negatively impact performance. [-Rpass-analysis=loop-vectorize]
      A[i*SIZE+j] = 0.2  * (B[i*SIZE+j] + B[i*SIZE+j-1] + B[i*SIZE+j+1] + B[(i+1)*SIZE+j] + B[(i-1)*SIZE+j]);
                           ^

UVE executed 86477 less instructions
RVV executed 69479 less instructions
UVE executed 7775 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 79020    | 9541 | -69479     | -87.93         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 88243    | 1766 | -86477     | -98.00         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 9541     | 1766 | -7775      | -81.49         |
|----------|------|------------|----------------|


Kernel jacobi-2d is similar enough

### Attempting to compile and run kernel jacobi-2d (size: 2500, type: double) ...


benchmarks/jacobi-2d/kernel.c:211:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int j = 1; j < SIZE - 1; j++) {
    ^
benchmarks/jacobi-2d/kernel.c:211:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/jacobi-2d/kernel.c:216:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int j = 1; j < SIZE - 1; j++) {
    ^
benchmarks/jacobi-2d/kernel.c:216:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 75533 less instructions
RVV executed 55367 less instructions
UVE executed 10943 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 69804    | 14437 | -55367     | -79.32         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 79027    | 3494  | -75533     | -95.58         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 14437    | 3494  | -10943     | -75.80         |
|----------|-------|------------|----------------|


Kernel jacobi-2d is similar enough

### Attempting to compile and run kernel memcpy (size: 2500, type: byte) ...


benchmarks/memcpy/kernel.c:117:2: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
        for (int i = 0; i < SIZE; ++i) {
        ^

UVE executed 1504 less instructions
RVV executed 14384 less instructions
UVE executed 535 less instructions than RVV
|----------|-----|------------|----------------|
| Original | RVV | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 15004    | 620 | -14384     | -95.87         |
|----------|-----|------------|----------------|
| Original | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 1589     | 85  | -1504      | -94.65         |
|----------|-----|------------|----------------|
| RVV      | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 620      | 85  | -535       | -86.29         |
|----------|-----|------------|----------------|


Kernel memcpy is similar enough

### Attempting to compile and run kernel memcpy (size: 2500, type: half-word) ...


benchmarks/memcpy/kernel.c:117:2: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
        for (int i = 0; i < SIZE; ++i) {
        ^

UVE executed 2978 less instructions
RVV executed 14564 less instructions
UVE executed 277 less instructions than RVV
|----------|-----|------------|----------------|
| Original | RVV | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 15004    | 440 | -14564     | -97.07         |
|----------|-----|------------|----------------|
| Original | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 3141     | 163 | -2978      | -94.81         |
|----------|-----|------------|----------------|
| RVV      | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 440      | 163 | -277       | -62.95         |
|----------|-----|------------|----------------|


Kernel memcpy is similar enough

### Attempting to compile and run kernel memcpy (size: 2500, type: integer) ...


benchmarks/memcpy/kernel.c:117:2: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (int i = 0; i < SIZE; ++i) {
        ^

UVE executed 5947 less instructions
RVV executed 14173 less instructions
UVE executed 512 less instructions than RVV
|----------|-----|------------|----------------|
| Original | RVV | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 15004    | 831 | -14173     | -94.46         |
|----------|-----|------------|----------------|
| Original | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 6266     | 319 | -5947      | -94.91         |
|----------|-----|------------|----------------|
| RVV      | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 831      | 319 | -512       | -61.61         |
|----------|-----|------------|----------------|


Kernel memcpy is similar enough

### Attempting to compile and run kernel memcpy (size: 2500, type: float) ...


benchmarks/memcpy/kernel.c:117:2: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
        for (int i = 0; i < SIZE; ++i) {
        ^

UVE executed 12186 less instructions
RVV executed 14173 less instructions
UVE executed 512 less instructions than RVV
|----------|-----|------------|----------------|
| Original | RVV | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 15004    | 831 | -14173     | -94.46         |
|----------|-----|------------|----------------|
| Original | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 12505    | 319 | -12186     | -97.45         |
|----------|-----|------------|----------------|
| RVV      | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 831      | 319 | -512       | -61.61         |
|----------|-----|------------|----------------|


Kernel memcpy is similar enough

### Attempting to compile and run kernel memcpy (size: 2500, type: double) ...


benchmarks/memcpy/kernel.c:117:2: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (int i = 0; i < SIZE; ++i) {
        ^
benchmarks/memcpy/kernel.c:117:2: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 11874 less instructions
RVV executed 13088 less instructions
UVE executed 1285 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 15004    | 1916 | -13088     | -87.23         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 12505    | 631  | -11874     | -94.95         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 1916     | 631  | -1285      | -67.07         |
|----------|------|------------|----------------|


Kernel memcpy is similar enough

### Attempting to compile and run kernel mvt (size: 2500, type: byte) ...


benchmarks/mvt/kernel.c:373:7: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:377:7: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:377:7: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 49941 less instructions
RVV executed 373 more instructions
UVE executed 45463 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 45807    | 46180 | 373        | 0.81           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 50658    | 717   | -49941     | -98.58         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 46180    | 717   | -45463     | -98.45         |
|----------|-------|------------|----------------|


Kernel mvt is similar enough

### Attempting to compile and run kernel mvt (size: 2500, type: half-word) ...


benchmarks/mvt/kernel.c:373:7: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:377:7: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^

UVE executed 49592 less instructions
RVV executed 671 more instructions
UVE executed 45562 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 45908    | 46579 | 671        | 1.46           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 50609    | 1017  | -49592     | -97.99         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 46579    | 1017  | -45562     | -97.82         |
|----------|-------|------------|----------------|


Kernel mvt is similar enough

### Attempting to compile and run kernel mvt (size: 2500, type: integer) ...


benchmarks/mvt/kernel.c:373:7: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:377:7: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^

UVE executed 38992 less instructions
RVV executed 23368 less instructions
UVE executed 20923 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 45908    | 22540 | -23368     | -50.90         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 40609    | 1617  | -38992     | -96.02         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 22540    | 1617  | -20923     | -92.83         |
|----------|-------|------------|----------------|


Kernel mvt is similar enough

### Attempting to compile and run kernel mvt (size: 2500, type: float) ...


benchmarks/mvt/kernel.c:373:7: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:377:7: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^

UVE executed 33992 less instructions
RVV executed 20266 less instructions
UVE executed 19025 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 40908    | 20642 | -20266     | -49.54         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 35609    | 1617  | -33992     | -95.46         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 20642    | 1617  | -19025     | -92.17         |
|----------|-------|------------|----------------|


Kernel mvt is similar enough

### Attempting to compile and run kernel mvt (size: 2500, type: double) ...


benchmarks/mvt/kernel.c:373:7: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:373:7: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/mvt/kernel.c:377:7: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
      for (int j = 0; j < sizeN; j++)
      ^
benchmarks/mvt/kernel.c:377:7: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 33092 less instructions
RVV executed 30119 less instructions
UVE executed 8272 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 40908    | 10789 | -30119     | -73.63         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 35609    | 2517  | -33092     | -92.93         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 10789    | 2517  | -8272      | -76.67         |
|----------|-------|------------|----------------|


Kernel mvt is similar enough

### Attempting to compile and run kernel saxpy (size: 2500, type: byte) ...


benchmarks/saxpy/kernel.c:186:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (int i = 0; i < SIZE; i++) {
    ^

UVE executed 19878 less instructions
RVV executed 21599 less instructions
UVE executed 777 less instructions than RVV
|----------|-----|------------|----------------|
| Original | RVV | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 22504    | 905 | -21599     | -95.98         |
|----------|-----|------------|----------------|
| Original | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 20006    | 128 | -19878     | -99.36         |
|----------|-----|------------|----------------|
| RVV      | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 905      | 128 | -777       | -85.86         |
|----------|-----|------------|----------------|


Kernel saxpy is similar enough

### Attempting to compile and run kernel saxpy (size: 2500, type: half-word) ...


benchmarks/saxpy/kernel.c:186:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (int i = 0; i < SIZE; i++) {
    ^

UVE executed 19762 less instructions
RVV executed 21893 less instructions
UVE executed 366 less instructions than RVV
|----------|-----|------------|----------------|
| Original | RVV | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 22504    | 611 | -21893     | -97.28         |
|----------|-----|------------|----------------|
| Original | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 20007    | 245 | -19762     | -98.78         |
|----------|-----|------------|----------------|
| RVV      | UVE | Difference | Difference (%) |
|----------|-----|------------|----------------|
| 611      | 245 | -366       | -59.90         |
|----------|-----|------------|----------------|


Kernel saxpy is similar enough

### Attempting to compile and run kernel saxpy (size: 2500, type: integer) ...


benchmarks/saxpy/kernel.c:186:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (int i = 0; i < SIZE; i++) {
    ^

UVE executed 19526 less instructions
RVV executed 21342 less instructions
UVE executed 683 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 22504    | 1162 | -21342     | -94.84         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 20005    | 479  | -19526     | -97.61         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 1162     | 479  | -683       | -58.78         |
|----------|------|------------|----------------|


Kernel saxpy is similar enough

### Attempting to compile and run kernel saxpy (size: 2500, type: float) ...


benchmarks/saxpy/kernel.c:186:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (int i = 0; i < SIZE; i++) {
    ^

UVE executed 17026 less instructions
RVV executed 18846 less instructions
UVE executed 679 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 20004    | 1158 | -18846     | -94.21         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 17505    | 479  | -17026     | -97.26         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 1158     | 479  | -679       | -58.64         |
|----------|------|------------|----------------|


Kernel saxpy is similar enough

### Attempting to compile and run kernel saxpy (size: 2500, type: double) ...


benchmarks/saxpy/kernel.c:186:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < SIZE; i++) {
    ^
benchmarks/saxpy/kernel.c:186:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 16558 less instructions
RVV executed 17449 less instructions
UVE executed 1608 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 20004    | 2555 | -17449     | -87.23         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 17505    | 947  | -16558     | -94.59         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 2555     | 947  | -1608      | -62.94         |
|----------|------|------------|----------------|


Kernel saxpy is similar enough

### Attempting to compile and run kernel sgd (size: 0, type: double) ...


benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
            for (j = 0; j /*< BATCH_SIZE && b + j*/ < PB_N; j++)
            ^
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
benchmarks/sgd/kernel.c:276:13: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:265:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (i = 0; i < PB_N /*BATCH_SIZE*/; i++)
        ^
benchmarks/sgd/kernel.c:265:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:257:9: remark: loop not vectorized: cannot identify array bounds [-Rpass-analysis=loop-vectorize]
        for (i = 0; i /*< BATCH_SIZE && b+i*/ < PB_N; i++) {
        ^
benchmarks/sgd/kernel.c:257:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
benchmarks/sgd/kernel.c:289:5: remark: loop not vectorized: cannot identify array bounds [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++) {
    ^
benchmarks/sgd/kernel.c:289:5: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
benchmarks/sgd/kernel.c:301:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++)
    ^
benchmarks/sgd/kernel.c:301:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:306:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++)
    ^
benchmarks/sgd/kernel.c:306:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:310:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++)
    ^
benchmarks/sgd/kernel.c:310:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:289:5: remark: loop not vectorized: cannot identify array bounds [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++) {
    ^
benchmarks/sgd/kernel.c:289:5: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
benchmarks/sgd/kernel.c:301:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++)
    ^
benchmarks/sgd/kernel.c:301:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:306:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++)
    ^
benchmarks/sgd/kernel.c:306:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/sgd/kernel.c:310:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (int i = 0; i < PB_N; i++)
    ^
benchmarks/sgd/kernel.c:310:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 4835444 less instructions
RVV executed 6959623 less instructions
UVE executed 770725 less instructions than RVV
|----------|---------|------------|----------------|
| Original | RVV     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 8408724  | 1449101 | -6959623   | -82.77         |
|----------|---------|------------|----------------|
| Original | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 5513820  | 678376  | -4835444   | -87.70         |
|----------|---------|------------|----------------|
| RVV      | UVE     | Difference | Difference (%) |
|----------|---------|------------|----------------|
| 1449101  | 678376  | -770725    | -53.19         |
|----------|---------|------------|----------------|


Kernel sgd is similar enough

### Attempting to compile and run kernel spmv_ellpack (size: 0, type: double) ...


benchmarks/spmv_ellpack/kernel.c:62:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (j = 0; j < L; j++) {
        ^
benchmarks/spmv_ellpack/kernel.c:62:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 48414 less instructions
RVV executed 27652 less instructions
UVE executed 23722 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 55832    | 28180 | -27652     | -49.53         |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 52872    | 4458  | -48414     | -91.57         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 28180    | 4458  | -23722     | -84.18         |
|----------|-------|------------|----------------|


Kernel spmv_ellpack is similar enough

### Attempting to compile and run kernel spmv_ellpack_delimiters (size: 0, type: double) ...


benchmarks/spmv_ellpack_delimiters/kernel.c:71:9: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
        for (int j = 0; j < cur_nnz; j++) {
        ^
benchmarks/spmv_ellpack_delimiters/kernel.c:71:9: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 21889 less instructions
RVV executed 3209 more instructions
UVE executed 25777 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 25560    | 28769 | 3209       | 12.55          |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 24881    | 2992  | -21889     | -87.97         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 28769    | 2992  | -25777     | -89.60         |
|----------|-------|------------|----------------|


Kernel spmv_ellpack_delimiters is similar enough

### Attempting to compile and run kernel stream (size: 2500, type: byte) ...


benchmarks/stream/kernel.c:383:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:386:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:389:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:392:5: remark: vectorized loop (vectorization width: vscale x 8, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^

UVE executed 42852 less instructions
RVV executed 76739 less instructions
UVE executed 2894 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 80016    | 3277 | -76739     | -95.90         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 43235    | 383  | -42852     | -99.11         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 3277     | 383  | -2894      | -88.31         |
|----------|------|------------|----------------|


Kernel stream is similar enough

### Attempting to compile and run kernel stream (size: 2500, type: half-word) ...


benchmarks/stream/kernel.c:383:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:386:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:389:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:392:5: remark: vectorized loop (vectorization width: vscale x 4, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^

UVE executed 48079 less instructions
RVV executed 77689 less instructions
UVE executed 1593 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 80016    | 2327 | -77689     | -97.09         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 48813    | 734  | -48079     | -98.50         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 2327     | 734  | -1593      | -68.46         |
|----------|------|------------|----------------|


Kernel stream is similar enough

### Attempting to compile and run kernel stream (size: 2500, type: integer) ...


benchmarks/stream/kernel.c:383:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:386:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:389:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:392:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^

UVE executed 62349 less instructions
RVV executed 75578 less instructions
UVE executed 3002 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 80016    | 4438 | -75578     | -94.45         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 63785    | 1436 | -62349     | -97.75         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 4438     | 1436 | -3002      | -67.64         |
|----------|------|------------|----------------|


Kernel stream is similar enough

### Attempting to compile and run kernel stream (size: 2500, type: float) ...


benchmarks/stream/kernel.c:383:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:386:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:389:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:392:5: remark: vectorized loop (vectorization width: vscale x 2, interleaved count: 2) [-Rpass=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^

UVE executed 66079 less instructions
RVV executed 73082 less instructions
UVE executed 2998 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 77516    | 4434 | -73082     | -94.28         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 67515    | 1436 | -66079     | -97.87         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 4434     | 1436 | -2998      | -67.61         |
|----------|------|------------|----------------|


Kernel stream is similar enough

### Attempting to compile and run kernel stream (size: 2500, type: double) ...


benchmarks/stream/kernel.c:383:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:383:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/stream/kernel.c:386:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:386:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/stream/kernel.c:389:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:389:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]
benchmarks/stream/kernel.c:392:5: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]
    for (j=0; j<sizeN; j++)
    ^
benchmarks/stream/kernel.c:392:5: remark: vectorized loop (vectorization width: vscale x 1, interleaved count: 1) [-Rpass=loop-vectorize]

UVE executed 64675 less instructions
RVV executed 67623 less instructions
UVE executed 7053 less instructions than RVV
|----------|------|------------|----------------|
| Original | RVV  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 77516    | 9893 | -67623     | -87.24         |
|----------|------|------------|----------------|
| Original | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 67515    | 2840 | -64675     | -95.79         |
|----------|------|------------|----------------|
| RVV      | UVE  | Difference | Difference (%) |
|----------|------|------------|----------------|
| 9893     | 2840 | -7053      | -71.29         |
|----------|------|------------|----------------|


Kernel stream is similar enough

### Attempting to compile and run kernel trisolv (size: 2500, type: byte) ...


benchmarks/trisolv/kernel.c:286:18: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/trisolv/kernel.c:286:39 [-Rpass-analysis=loop-vectorize]
            x[i] -= L[i * SIZE + j] * x[j];
                 ^
benchmarks/trisolv/kernel.c:283:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (int j = 0; j < i; ++j) {
        ^

UVE executed 12633 less instructions
UVE executed 11568 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 11980    | 11980 | 0          | 0.00           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 13045    | 412   | -12633     | -96.84         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 11980    | 412   | -11568     | -96.56         |
|----------|-------|------------|----------------|


Kernel trisolv is similar enough

### Attempting to compile and run kernel trisolv (size: 2500, type: half-word) ...


benchmarks/trisolv/kernel.c:286:18: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/trisolv/kernel.c:286:39 [-Rpass-analysis=loop-vectorize]
            x[i] -= L[i * SIZE + j] * x[j];
                 ^
benchmarks/trisolv/kernel.c:283:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (int j = 0; j < i; ++j) {
        ^

UVE executed 12534 less instructions
UVE executed 11567 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 12030    | 12030 | 0          | 0.00           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 12997    | 463   | -12534     | -96.44         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 12030    | 463   | -11567     | -96.15         |
|----------|-------|------------|----------------|


Kernel trisolv is similar enough

### Attempting to compile and run kernel trisolv (size: 2500, type: integer) ...


benchmarks/trisolv/kernel.c:286:18: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/trisolv/kernel.c:286:39 [-Rpass-analysis=loop-vectorize]
            x[i] -= L[i * SIZE + j] * x[j];
                 ^
benchmarks/trisolv/kernel.c:283:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (int j = 0; j < i; ++j) {
        ^

UVE executed 9933 less instructions
UVE executed 11365 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 11930    | 11930 | 0          | 0.00           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 10498    | 565   | -9933      | -94.62         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 11930    | 565   | -11365     | -95.26         |
|----------|-------|------------|----------------|


Kernel trisolv is similar enough

### Attempting to compile and run kernel trisolv (size: 2500, type: float) ...


benchmarks/trisolv/kernel.c:286:18: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/trisolv/kernel.c:286:39 [-Rpass-analysis=loop-vectorize]
            x[i] -= L[i * SIZE + j] * x[j];
                 ^
benchmarks/trisolv/kernel.c:283:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (int j = 0; j < i; ++j) {
        ^

UVE: Values were 872898.812500 and 872898.562500 with difference of 0.25 at index 16
UVE: Values were -16372533.000000 and -16372531.000000 with difference of 2 at index 18
UVE: Values were -20628568.000000 and -20628566.000000 with difference of 2 at index 19
UVE: Values were -60339964.000000 and -60339968.000000 with difference of 4 at index 20
UVE: Values were 113169176.000000 and 113169184.000000 with difference of 8 at index 21
UVE: Values were -315977856.000000 and -315977824.000000 with difference of 32 at index 22
UVE: Values were 147261728.000000 and 147261712.000000 with difference of 16 at index 23
UVE: Values were 651010560.000000 and 651010432.000000 with difference of 128 at index 25
UVE: Values were -1185378560.000000 and -1185377920.000000 with difference of 640 at index 26
UVE: Values were -12704761856.000000 and -12704755712.000000 with difference of 6144 at index 27
UVE: Values were 7187345408.000000 and 7187340800.000000 with difference of 4608 at index 28
UVE: Values were 39105835008.000000 and 39105814528.000000 with difference of 20480 at index 29
UVE: Values were 66696314880.000000 and 66696286208.000000 with difference of 28672 at index 30
UVE: Values were 48554946560.000000 and 48554930176.000000 with difference of 16384 at index 31
UVE: Values were -607494537216.000000 and -607494275072.000000 with difference of 262144 at index 32
UVE: Values were 610435072000.000000 and 610434744320.000000 with difference of 327680 at index 33
UVE: Values were -1177840254976.000000 and -1177839861760.000000 with difference of 393216 at index 34
UVE: Values were -1110662184960.000000 and -1110662053888.000000 with difference of 131072 at index 35
UVE: Values were -2864352329728.000000 and -2864351805440.000000 with difference of 524288 at index 36
UVE: Values were 6941679026176.000000 and 6941676929024.000000 with difference of 2097152 at index 37
UVE: Values were 7714436022272.000000 and 7714433925120.000000 with difference of 2097152 at index 38
UVE: Values were -937770024960.000000 and -937770352640.000000 with difference of 327680 at index 39
UVE: Values were 2280469561344.000000 and 2280468512768.000000 with difference of 1048576 at index 40
UVE: Values were 324196564992.000000 and 324198203392.000000 with difference of 1638400 at index 41
UVE: Values were -15020143411200.000000 and -15020142362624.000000 with difference of 1048576 at index 42
UVE: Values were 181748151353344.000000 and 181748101021696.000000 with difference of 50331648 at index 43
UVE: Values were -191808457932800.000000 and -191808407601152.000000 with difference of 50331648 at index 44
UVE: Values were 82725641912320.000000 and 82725616746496.000000 with difference of 25165824 at index 45
UVE: Values were -2094262694969344.000000 and -2094262158098432.000000 with difference of 536870912 at index 46
UVE: Values were -3798025621209088.000000 and -3798024815902720.000000 with difference of 805306368 at index 47
UVE: Values were 28793297543626752.000000 and 28793295396143104.000000 with difference of 2147483648 at index 48
UVE: Values were 54335648441565184.000000 and 54335639851630592.000000 with difference of 8589934592 at index 49
UVE executed 8708 less instructions
UVE executed 10140 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 10705    | 10705 | 0          | 0.00           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 9273     | 565   | -8708      | -93.91         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 10705    | 565   | -10140     | -94.72         |
|----------|-------|------------|----------------|


Kernel trisolv: Did not generate result similar enough

### Attempting to compile and run kernel trisolv (size: 2500, type: double) ...


benchmarks/trisolv/kernel.c:286:18: remark: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. Memory location is the same as accessed at benchmarks/trisolv/kernel.c:286:39 [-Rpass-analysis=loop-vectorize]
            x[i] -= L[i * SIZE + j] * x[j];
                 ^
benchmarks/trisolv/kernel.c:283:9: remark: loop not vectorized [-Rpass-missed=loop-vectorize]
        for (int j = 0; j < i; ++j) {
        ^

UVE: Values were -3798025834736546.500000 and -3798025834736547.500000 with difference of 1 at index 47
UVE executed 8483 less instructions
UVE executed 9915 less instructions than RVV
|----------|-------|------------|----------------|
| Original | RVV   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 10705    | 10705 | 0          | 0.00           |
|----------|-------|------------|----------------|
| Original | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 9273     | 790   | -8483      | -91.48         |
|----------|-------|------------|----------------|
| RVV      | UVE   | Difference | Difference (%) |
|----------|-------|------------|----------------|
| 10705    | 790   | -9915      | -92.62         |
|----------|-------|------------|----------------|


Kernel trisolv: Did not generate result similar enough
